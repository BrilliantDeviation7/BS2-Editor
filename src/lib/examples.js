export const examples = {
	"control": {
		"PAUSE.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: PAUSE\n'This program demonstrates the PAUSE command's time delays. Once a second,\n'the program will put the message, \"Paused...\" on the screen.\n\nInit:\n  PAUSE 200                             'short startup-pause\n\nMain:\n  DO\n    DEBUG \"Paused...\", CR\n    PAUSE 1000\n  LOOP",
		"DO-LOOP.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: DO-LOOP\n'This program creates a little guessing game.  It starts by creating\n'a (psuedo) random number between 1 and 10.  The inner loop will run\n'until the answer is guessed or 3 tries have been attempted.  The\n'outer loop has no condition and will cause the inner loop code to\n'run until the BASIC Stamp is reprogrammed.\n\nrVal            VAR     Word            'random value\nanswer          VAR     Byte            'game answer\nguess           VAR     Byte            'player guess\ntries           VAR     Nib             'number of tries\n\nInit: \n  PAUSE 200                             'short startup-pause\n\nMain:\n  DO\n    RANDOM rVal\n    answer = rVal.LOWBYTE */ 10 + 1     'create 1 - 10 answer\n    tries = 0\n\n    DO                                  'get answer until out of tries\n      DEBUG CLS, \"Guess a number (1 - 10). \", CLREOL\n      DEBUGIN DEC guess                 'get new guess\n      tries = tries + 1                 'update tries count\n      IF (guess <> answer) THEN \n        DEBUG CR, \"Wrong.\"\n        PAUSE 500\n      ENDIF\n    LOOP UNTIL ((tries = 3) OR (guess = answer))\n\n    IF (guess = answer) THEN            ' test reason for loop end\n      DEBUG CR, \"You got it!\"\n    ELSE\n      DEBUG CR, \"Sorry ... the answer was \", DEC answer, \".\"\n    ENDIF\n    PAUSE 1000\n  LOOP                                  ' run again",
		"FOR-NEXT.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: FOR-NEXT\n'This example uses a FOR...NEXT loop to churn out a series of sequential\n'squares (numbers 1, 2, 3, 4... raised to the second power) by using a\n'variable to set the FOR...NEXT's StepValue parameter, and incrementing \n'StepValue within the loop.  Sir Isaac Newton is generally credited with\n'the discovery of this technique.\n\nsquare          VAR     Byte            'FOR/NEXT counter\nstepSize        VAR     Byte            'step size, increase by 2 each loop\n\nSetup:\n  PAUSE 200                             'short startup-pause\n  stepSize = 1\n  square = 1\n\nMain:\n  FOR square = 1 TO 250 STEP stepSize   'show squares up to 250\n    DEBUG DEC ? square                  'display on screen\n    stepSize = stepSize + 2             'add 2 to stepSize\n  NEXT                                  'loop until square > 250\n  END",
		"EXIT.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: EXIT\n'This program demonstrates the early termination of DO...LOOP and\n'FOR..NEXT loop structures.  IF...THEN is used to test a condition,\n'and when true, EXIT will terminate the loop.\n\ncol             VAR     Nib\nrow             VAR     Nib\n\nSetup:\n  PAUSE 200                             'short startup-pause\n  col = 0\n\nMain:\n  DO WHILE (col < 10)                   'attempt 10 iterations\n    FOR row = 0 TO 15                   'attempt 16 iterations\n      IF (row > 9) THEN EXIT            'terminate when row > 9\n      DEBUG CRSRXY, (col * 8), row,     'print col/row at location\n            DEC col, \"/\", DEC row, CR\n    NEXT\n    col = col + 1                       'update column\n    IF (col = 3) THEN EXIT              'terminate when col = 3\n  LOOP\n  END",
		"IF-THEN-ELSE.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: IF-THEN-ELSE\n'This program is an expansion on IF-THEN.  It generates a series of 16-bit\n'random numbers and tests each to determine whether they're evenly divisible\n'by 3. If a number is evenly divisible by 3, then it is printed, otherwise,\n'the program generates another random number. The program quits when it's\n'printed 10 numbers.  It also displays the tallied up Hits, Misses, and Samples.\n\nsample          VAR     Word            'Random number to be tested\nhits            VAR     Nib             'Number of hits\nmisses          VAR     Word            'Number of misses\n\nSetup:\n  PAUSE 200                             'short startup-pause\n  sample = 11500\n\nMain:\n  DO\n    RANDOM sample                       'Put a random number into sample\n    IF ((sample // 3) = 0) THEN         'divisible by 3?\n      DEBUG DEC5 sample,                '- yes, print value and message\n            \" is divisible by 3\", CR\n      hits = hits + 1                   'count hits (divisble by 3)\n    ELSE\n      misses = misses + 1               'count misses\n    ENDIF\n  LOOP UNTIL (hits = 10)                'quit after 10 hits\n\n  DEBUG CR,\n        \"All done.\", CR, CR,            'display results\n        \"Hits:    \", DEC hits, CR,\n        \"Misses:  \", DEC misses, CR,\n        \"Samples: \", DEC (hits + misses)\n  END",
		"IF-THEN.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: IF-THEN\n'The program below generates a series of 16-bit random numbers and tests\n'each to determine whether they're evenly divisible by 3. If a number is\n'evenly divisible by 3, then it is printed, otherwise, the program generates\n'another random number.  The program quits when it's printed 10 numbers.\n\nsample          VAR     Word            'Random number to be tested\nsamps           VAR     Nib             'Number of samples taken\ntemp            VAR     Nib             'Temporary workspace\n\n\nSetup:\n  PAUSE 200                             'short startup-pause\n  sample = 11500\n\nMult3:\n  RANDOM sample                         'Put a random number into sample\n  temp = sample // 3\n  IF temp <> 0 THEN Mult3               'Not multiple of 3? -- try again\n    DEBUG DEC5 sample, \" divides by 3\", CR\n    samps = samps + 1                   'Count multiples of 3\n    IF samps = 10 THEN Done             'Quit with 10 samples\n  GOTO Mult3                            'keep checking\n\nDone:\n  DEBUG CR, \"All done.\"\n  END",
		"RETURN.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: RETURN\n'This program demonstrates a potential bug caused by allowing a program\n'to \"fall into\" a subroutine.  The program was intented to indicate that it\n'is \"Starting...\", then \"Executing Subroutine,\", then \"Returned...\" from\n'the subroutine and then stop.  Since we left out the END command (indicated\n'in the comments), the program then falls into the subroutine, displays the\n'message \"Executing...\" again and then RETURNs to the start of the program and\n'runs continuously in an endless loop.\n\nInit:\n  PAUSE 200                             'short startup-pause\n\nReset:\n  DEBUG \"Starting Program\", CR          'show start-up\n\nMain:\n  PAUSE 1000\n  GOSUB Demo_Sub                        'call the subroutine\n  PAUSE 1000\n  DEBUG \"Returned from Subroutine\", CR  'show that we're back\n  PAUSE 1000\n                                        '<-- Forgot to put END here\n\nDemo_Sub:\n  DEBUG \"  Executing Subroutine\", CR    'show subroutine activity\n  RETURN",
		"ON-GOSUB.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: ON-GOSUB\n'This program demonstrates a simple task manager that can be used in\n'a variety of applications.  It is particularly useful in robotics and\n'industrial applications.  The advantage of this design is that task\n'code routines may be called from other places in the program, including\n'other tasks, and the overal program flow is maintained.\n\ntask            VAR     Nib\n\nInit:\n  PAUSE 200                                     'short startup-pause\n\nMain:\n  DO\n    ON task GOSUB Task_0, Task_1, Task_2        'run current task\n    task = task + 1 // 3                        'update task pointer\n    PAUSE 1000\n  LOOP\n\nTask_0:\n  DEBUG \"Running Task 0\", CR\n  RETURN\n\nTask_1:\n  DEBUG \"Running Task 1\", CR\n  RETURN\n\nTask_2:\n  DEBUG \"Running Task 2\", CR\n  RETURN",
		"ON-GOTO.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: ON-GOTO\n'This program shows how the value of an index variable (idx) controls the\n'destination of the ON...GOTO instruction.\n\nidx             VAR     Byte\n\nInit:\n  PAUSE 200                                    'short startup-pause\n\nMain:\n  DEBUG \"idx: \", DEC idx, \" \"\n  ON idx GOTO Case_0, Case_1, Case_2           'if idx = 0..2 goto label\n  DEBUG \"ON..GOTO target error.\", CR           'message if idx is out of range\n\nUpdate:\n  idx = idx + 1 // 4                           'force idx to be 0..3\n  PAUSE 1000\n  GOTO Main\n\nCase_0:\n  DEBUG \"Running Case_0 routine\", CR\n  GOTO Update\n\nCase_1:\n  DEBUG \"Running Case_1 routine\", CR\n  GOTO Update\n\nCase_2:\n  DEBUG \"Running Case_2 routine\", CR\n  GOTO Update",
		"GOSUB.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: GOSUB\n'This program is a guessing game that generates a random number in a\n'subroutine called Pick_A_Number.  It is written to stop after three\n'guesses. To see a common bug associated with GOSUB, delete or comment\n'out the line beginning with END after the FOR-NEXT loop.  This means\n'that after the loop is finished, the program will wander into the\n'Pick_A_Number subroutine.  When the RETURN at the source's end executes,\n'the program will go back to the beginning.  This will cause the program\n'to execute endlessly.  Make sure that your programs can't accidentally\n'execute subroutines!\n\nrounds          VAR     Byte            'number of reps\nnumGen          VAR     Word            'random number holder\nmyNum           VAR     Byte            'random number, 1-10\n\nSetup:\n  PAUSE 200                             'short startup-pause\n  numGen = 11500                        'initialize random \"seed\"\n\nMain:\n  FOR rounds = 1 TO 3\n    DEBUG CLS, \"Think of a number from 1 to 10\", CR\n    GOSUB Pick_A_Number\n    PAUSE 2000                          'dramatic pause\n    DEBUG \"My number was: \", DEC myNum  'show the number\n    PAUSE 1000                          'another pause.\n  NEXT\n  DEBUG CLS, \"Done\"\n  END                                   'end program\n\n'Random-number subroutine. A subroutine is just a piece of code with\n'the RETURN instruction at the end. Always make sure your program enters\n'subroutines with a GOSUB. If you don't, the RETURN won't have the\n'correct address, and your program will have a bug!\n\nPick_A_Number:\n  RANDOM numGen                         'stir up the bits of NumGen.\n  DEBUG \"  (random value = \", DEC numGen, \")\", CR, CR\n  myNum = numGen / 6550 MIN 1           'scale to fit 1-10 range.\n  RETURN                                'go back to instruction after\n                                        'the GOSUB that got us here",
		"GOTO.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: GOTO\n'This program isn't practical at all, but demonstrates the use of GOTO to\n'jump around the code.  This code jumps between three different routines,\n'each of which print something different on the screen.  The routines are\n'out of order for sake of example.\n\nInit:\n  PAUSE 200                             'short startup-pause\n\nStart:\n  GOTO Routine1\n\nRoutine2:\n  DEBUG \"We're in routine #2\", CR\n  PAUSE 1000\n  GOTO Routine3\n\nRoutine1:\n  DEBUG \"We're in routine #1\", CR\n  PAUSE 1000\n  GOTO Routine2\n\nRoutine3:\n  DEBUG \"We're in routine #3\", CR\n  PAUSE 1000\n  GOTO Routine1",
		"BRANCH.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: BRANCH\n'This program shows how the value of an index variable (idx) controls the \n'destination of the BRANCH instruction.\n\nidx       VAR  Byte\n\nInit:\n  PAUSE 200                                     'short startup-pause\n\nMain:\n  DEBUG \"idx: \", DEC idx, \" \"\n  BRANCH idx, [Task_0, Task_1, Task_2]          'branch to task\n  DEBUG \"BRANCH target error...\", CR, CR        '... unless out of range\n\nNext_Task:\n  idx = idx + 1 // 4                            'force idx to be 0..3\n  PAUSE 250\n  GOTO Main\n\nTask_0:\n  DEBUG \"BRANCHed to Task_0\", CR\n  GOTO Next_Task\n\nTask_1:\n  DEBUG \"BRANCHed to Task_1\", CR\n  GOTO Next_Task\n\nTask_2:\n  DEBUG \"BRANCHed to Task_2\", CR\n  GOTO Next_Task",
		"SLEEP.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: SLEEP\n'This program lights an LED and then goes to sleep. Connect an LED to pin\n'0 as shown in the description of SLEEP in the manual and run the program.\n'The LED will turn on, then the BASIC Stamp will go to sleep. During sleep,\n'the LED will remain on, but will blink at intervals of approximately 2.3\n'seconds due to the watchdog timeout and reset.\n\nMain:\n  LOW 0                                 'turn LED on\n\nSnooze:\n  DO\n    SLEEP 10                            'sleep for about 10 seconds\n  LOOP",
		"STOP.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: STOP\n'This program is similar to END, NAP, and SLEEP except that the LED \n'will not blink since the STOP command prevents the BASIC Stamp from\n'entering low power mode at the end of the code.  Use the circuit \n'shown in the description of the SLEEP command for this example.\n\nMain:\n  LOW 0                                 'turn LED on\n  STOP                                  'stop program",
	},
	"data": {
		"DATA.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: DATA\n'This program stores a number of large text strings into EEPROM with the DATA\n'directive and then sends them, one character at a time via the DEBUG command.\n'This is a good demonstration of how to save program space by storing large\n'amounts of data in EEPROM directly, rather than embedding the data into separate\n'DEBUG commands.\n\nidx             VAR     Word            'current location number\nphrase          VAR     Nib             'current phrase number\nchar            VAR     Byte            'character to print\n\n' ----- Define all text phrases (out of order, just for fun!) -----\n'\nText1           DATA    \"Here is the first part of a large chunk of text \"\n                DATA    \"data \", CR, \"that needs to be transmitted.  There's \"\n                DATA    \"a 5 second delay\", CR, \"between text paragraphs. \", CR\n                DATA    CR, 0\n\nText3           DATA    \"The alternative (having multiple DEBUGs or SEROUTs, \"\n                DATA    \"each \", CR, \"with their own line of text) consumes \"\n                DATA    \"MUCH more EEPROM \", CR, \"(program/data) space. \", CR\n                DATA    CR, 0\n\nText6           DATA    \"The 0 at the end of data blocks is used by this program \" \n                DATA    \"to indicate\", CR, \"we've reached the End of Text.  The Main \"\n                DATA    \"routine pauses in-between each\", CR, \"block of text, \"\n                DATA    \"and then uses a LOOKUP command to retrieve the location\", CR\n                DATA    \"of the next desired block of text to print. \", 0\n\nText4           DATA    CLS, \"This program also demonstrates retrieving data \"\n                DATA    \"out of order \", CR, \"in relation to the way it is \"\n                DATA    \"stored in EEPROM.  Additionally, \", CR, \"control codes \"\n                DATA    \"(like carriage-returns, clear-screens, etc) can \", CR\n                DATA    \"be embedded right in the data, as it is here. \", CR\n                DATA    CR, 0\n\nText2           DATA    \"This is an example of a good way to save space in \"\n                DATA    \"your \", CR, \"BASIC Stamp's program by storing data \"\n                DATA    \"into EEPROM and \", CR, \"retrieving it, one byte at a \"\n                DATA    \"time, and transmitting it \", CR, \"with just a single \"\n                DATA    \"DEBUG (or SEROUT) command.\", CR, CR, 0\n\nText5           DATA    \"The Print_It routine simply takes the idx variable, \"\n                DATA    \"retrieves \", CR, \"the character at the EEPROM location \"\n                DATA    \"pointed to by it, and \", CR, \"prints it to the screen \"\n                DATA    \"until it finds a byte with a value of 0.\", CR, CR, 0\n\nInit:\n  PAUSE 200                             'short startup-pause\n\nMain:\n  DEBUG CLS                             'Clear DEBUG window\n  FOR phrase = 1 TO 6                   'Print blocks one by one\n    LOOKUP (phrase - 1), [Text1, Text2, Text3, Text4, Text5, Text6], idx\n    GOSUB Print_It\n    PAUSE 5000                          'Pause for 5 seconds\n  NEXT\n  END\n\nPrint_It:\n  DO\n    READ idx, char                      'Get next character\n    idx = idx + 1                       'Point to next location\n    IF (char = 0) THEN EXIT             'If 0, we're done with block\n    DEBUG char                          'Otherwise, transmit it\n  LOOP\n  RETURN                                'Return to the main routine",
		"BUTTON.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: BUTTON\n'Connect an active-low circuit (shown in the BUTTON command description) to pin P0\n'of the BASIC Stamp.  When you press the button, the BUTTON command will detect the\n'low signal and then the DEBUG command will execute to display an asterisk (*) on\n'the Debug Terminal.  After the first button press, then BUTTON command will delay\n'approximately one second (200 x 5 ms) before auto-repeating at a rate of \n'approximately 100 ms (20 x 5 ms).  \n\nBtn             PIN     0\nbtnWrk          VAR     Byte\n\nInit:\n  PAUSE 200                                     'short startup-pause\n\nMain:\n  'Try changing the Delay parameter (3rd value) in BUTTON to see the effect:\n  '0 = no delay; 1-254 = varying delays before auto-repeat; 255 = no auto-repeat\n  '(only one action per button press)\n  '\n  'The BUTTON instruction makes the program branch to No_Press unless P0 = 0\n\n  PAUSE 5\n  BUTTON Btn, 0, 200, 20, btnWrk, 0, No_Press\n  DEBUG \"*\"\n\nNo_Press:\n  GOTO Main",
		"COUNT.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: COUNT\n'Connect an active-low button (shown in the BUTTON command description) to pin P0 \n'of the BASIC Stamp. The Debug Terminal will prompt you to press the button as\n'quickly as possible for a 1-second period.  When the count is done, the screen \n'will display your \"score,\" the total number of cycles registered by COUNT.  Note\n'that this score will almost always be greater than the actual number of presses\n'because of mechanical switch contact bounce.\n\nPushBtn         PIN     0               'Button on P0\n\nCapture         CON     1000            '1 second\n\n#SELECT $STAMP                          'Set DurAdj according to module type\n  #CASE BS2, BS2E\n    DurAdj      CON     $100            '/ 1\n  #CASE BS2SX\n    DurAdj      CON     $280            '/ 0.400\n  #CASE BS2P, BS2PX\n    DurAdj      CON     $37B            '/ 0.287\n  #CASE BS2PE\n    DurAdj      CON     $163            '/ 0.720\n#ENDSELECT\n\ncycles          VAR     Word            'counted cycles\n\nInit:\n  PAUSE 200                             'short startup-pause\n\nMain:\n  DO\n    DEBUG CLS, \"How many times can you press the button in 1 second?\", CR\n    PAUSE 1000\n    DEBUG \"Ready, set... \"\n    PAUSE 500\n    DEBUG \"GO!\", CR\n    COUNT PushBtn, (Capture */ DurAdj), cycles\n    DEBUG CR, \"Your score: \", DEC cycles, CR\n    PAUSE 3000\n    DEBUG \"Press button to go again.\"\n    DO : LOOP UNTIL (PushBtn = 0)       'wait for button press\n  LOOP",
		"FREQOUT.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: FREQOUT\n'This program demonstrates sound-effects generation by the BASIC Stamp.\n'Conditional compilation sets timing and frequency adjustment factors so\n'that the output will sound the same on any BS2 model.\n\nSpkr            PIN     10              'output pin for FREQOUT\n\n#SELECT $STAMP                          'Set TmAdj and FrAdj according to module type\n  #CASE BS2, BS2E\n    TmAdj       CON     $100            'x 1.0 (time adjust)\n    FrAdj       CON     $100            'x 1.0 (freq adjust)\n  #CASE BS2SX\n    TmAdj       CON     $280            'x 2.5\n    FrAdj       CON     $066            'x 0.4\n  #CASE BS2P\n    TmAdj       CON     $3C5            'x 3.77\n    FrAdj       CON     $044            'x 0.265\n  #CASE BS2PE\n    TmAdj       CON     $100            'x 1.0\n    FrAdj       CON     $0A9            'x 0.662\n  #CASE BS2PX\n    TmAdj       CON     $607            'x 6.03\n    FrAdj       CON     $2A             'x 0.166\n#ENDSELECT\n\nInit:\n  PAUSE 200                             'short startup-pause\n\nMain:\n  DEBUG \"Let's make a call...\", CR\n  'combine 350 Hz & 440 Hz\n  FREQOUT Spkr, 2000 */ TmAdj, 350 */ FrAdj, 440 */ FrAdj\n  'dial number (digits 150 ms on, 25 ms off)\n  DTMFOUT Spkr, 150 */ TmAdj, 25, [5, 5, 5, 1, 2, 1, 2]\n  PAUSE 500\n\n  'bad connection (SIT sequence)\n  FREQOUT Spkr, 375 */ TmAdj, 985 */ FrAdj\n  FREQOUT Spkr, 375 */ TmAdj, 1371 */ FrAdj\n  FREQOUT Spkr, 375 */ TmAdj, 1777 */ FrAdj\n\n  DEBUG \"Oops! -- try again...\", CR\n  PAUSE 1000\n  DTMFOUT Spkr, 150 */ TmAdj, 25, [5, 5, 5, 2, 2, 2, 2]\n  DEBUG \"Ringing\"\n  FREQOUT Spkr, 2000 */ TmAdj, 440 */ FrAdj, 480 */ FrAdj\n  PAUSE 4000\n  FREQOUT Spkr, 2000 */ TmAdj, 440 */ FrAdj, 480 */ FrAdj\n  INPUT Spkr\n  END\n",
		"HIGH_LOW.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: HIGH_LOW\n'This simple program sets I/O pin 0 high for 1/2 second and low for\n'1/2 second in an endless loop.  Connect an LED to P0 for a simple\n'blinker.\n\nMain:\n  DO\n    HIGH 0\n    PAUSE 500\n    LOW 0\n    PAUSE 500\n  LOOP\n",
		"INPUT_OUTPUT.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: INPUT_OUTPUT\n'This program demonstrates how the input/output direction of a pin is\n'determined by the corresponding bit of DIRS. It also shows that the\n'state of the pin itself (as reflected by the corresponding bit of INx)\n'is determined by the outside world when the pin is an input, and by the\n'corresponding bit of INx when it's an output. To set up the demo,\n'connect a 10k resistor from +5V to P7 on the BASIC Stamp. The resistor\n'to +5V puts a high (1) on the pin when it's an input. The BASIC Stamp\n'can override this state by writing a low (0) to bit 7 of OUTS and\n'changing the pin to output.\n\nInit:\n  PAUSE 200                             'short startup-pause\n\nMain:\n  INPUT 7                               'Make P7 an input\n  DEBUG \"State of P7: \",\n        BIN1 IN7, CR\n\n  OUT7 = 0                              'Write 0 to output latch\n  DEBUG \"After 0 written to OUT7: \",\n        BIN1 IN7, CR\n\n  OUTPUT 7                              'Make P7 an output\n  DEBUG \"After P7 changed to output: \",\n        BIN1 IN7\n  END",
		"RANDOM.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: RANDOM\n'This program uses RANDOM to simulate a coin toss. After 100 trials, it reports\n'the total number of heads and tails thrown.  Connect a button to I/O pin 7 as\n'shown in the RANDOM command description and run this program. \n\nBtn             PIN     7                       'button input\n\nflip            VAR     Word                    'a random number\ncoin            VAR     flip.BIT0               'Bit0 of the random number\ntrials          VAR     Byte                    'number of flips\nheads           VAR     Byte                    'throws that come up heads\ntails           VAR     Byte                    'throws that come up tails\nbtnWrk          VAR     Byte                    'workspace for BUTTON\n\nInit:\n  PAUSE 200                                     'short startup-pause\n\nStart:\n  DEBUG CLS, \"Press button to start\"\n\nMain:\n  FOR trials = 1 TO 100                         'flip coin 100 times\n\nHold:\n    RANDOM flip                                 'randomize while waiting\n    BUTTON Btn, 0, 250, 100, btnWrk, 0, Hold    'wait for button press\n    IF (coin = 0) THEN                          '0 = heads, 1 = tails\n      DEBUG CR, \"Heads!\"\n      heads = heads + 1                         'increment heads counter\n    ELSE\n      DEBUG CR, \"Tails...\"\n      tails = tails + 1                         'increment tails counter\n    ENDIF\n  NEXT\n\nDone:\n  DEBUG CR, CR, \"Heads: \", DEC heads, \" Tails: \", DEC tails\n  END",
		"RCTIME1.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: RCTIME1\n'This program shows the standard use of the RCTIME command measuring an\n'RC charge/discharge time. Use the circuit in the RCTIME description\n'(in the manual) with R = 10K pot and C = 0.1 uF. Connect the circuit to\n'pin 7 and run the program.  Adjust the pot and watch the value change in\n'the Debug Terminal.\n\nRC              PIN     7\n\nresult          VAR     Word\n\nInit:\n  PAUSE 200                             'short startup-pause\n\nMain:\n  DO\n    HIGH RC                             'charge the cap\n    PAUSE 1                             '  for 1 ms\n    RCTIME RC, 1, result                'measure RC discharge time\n    DEBUG HOME, DEC result              'display value\n    PAUSE 50\n  LOOP",
		"RCTIME2.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: RCTIME2\n'This program illustrates the use of RCTIME as a fast stopwatch. The\n'program energizes a relay coil, then measures how long it takes for the\n'relay contacts to close.  Use the circuit found in the RCTIME description.\n'Note that RCTIME doesn't start timing instantly -- as with all PBASIC \n'commands, it must be fetched from the program's EEPROM before executeing.\n\nCoil            PIN     6\nRC              PIN     7\n\n#SELECT $STAMP                          'Set Adjust according to module type \n  #CASE BS2, BS2E, BS2PE                \n    Adjust      CON     $200            'x 2 us per unit\n  #CASE BS2SX\n    Adjust      CON     $0CC            'x 0.8 us per unit\n  #CASE BS2P, BS2PX\n    Adjust      CON     $0C0            'x 0.75 us per unit\n#ENDSELECT\n\nresult          VAR     Word\n\nInit:\n  PAUSE 200                             'short startup-pause\n\nMain:\n  DO\n    LOW Coil                            'energize relay coil\n    RCTIME RC, 1, result                'measure time to contact closure\n    result = result */ Adjust           'adjust for device\n    DEBUG \"Time to close: \", DEC Result, CR\n    HIGH Coil                           'release relay\n    PAUSE 1000                          'wait one second\n  LOOP",
		"LOOKDOWN.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: LOOKDOWN\n'This program uses LOOKDOWN to determine the number of decimal digits in\n'a number. Since LOOKDOWN uses a zero-indexed table, the output will be\n'the number of digits minus one, so the DEBUG statement corrects for this.\n\naNum            VAR     Word            'random number\nstpSz           VAR     Word            'FOR-NEXT step size\nnumDig          VAR     Nib             'digits in aNum\n\nSetup:\n  PAUSE 200                             'short startup-pause\n  stpSz = 2\n\nMain:\n  FOR aNum = 0 TO 15000 STEP stpSz\n    LOOKDOWN aNum, <[0, 10, 100, 1000, 10000, 65535], numDig\n    'right-justify output\n    DEBUG \"aNum = \", REP \" \"\\(5-numDig), DEC aNum, TAB,\n          \"Digits = \", DEC numDig, CR\n    PAUSE 150\n    LOOKUP numDig, [2, 2, 5, 25, 250, 500, 1000], stpSz\n  NEXT\n  END",
		"LOOKUP.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: LOOKUP\n'This program uses LOOKUP to create a Debug Terminal animation of a spinning\n'propeller.  The animation consists of the four ASCII characters | / - \\\n'which, when printed rapidly in order at a fixed location, appears to spin.\n'A little imagination helps a lot here....\n\nidx             VAR     Nib\nframe           VAR     Byte\n\nInit:\n  PAUSE 200                             'short startup-pause\n\nSpinner:\n  DO\n    LOOKUP idx, [\"|/-\\\"], frame         'lookup current frame character\n    DEBUG HOME, \"Spinner: \", frame      'display\n    PAUSE 150                           'pause between frames\n    idx = idx + 1 // 4                  'update frame index (0..3)\n  LOOP                                  'loop forever\n",
		"READ.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: READ\n'This program reads a string of data stored in EEPROM. The EEPROM data is\n'downloaded to the BS2 at compile-time and remains there (even with the\n'power off) until overwritten. Put ASCII characters into EEPROM, followed\n'by 0, which will serve as the end-of-message marker.\n\nstrAddr         VAR     Word\nchar            VAR     Byte\n\nMsg1            DATA    \"BS2\", CR, \"EEPROM Storage!\", 0\n\nInit:\n  PAUSE 200                             'short startup-pause\n\nMain:\n  strAddr = Msg1                        'set to start of message\n  GOSUB String_Out\n  END\n\nString_Out:\n  DO\n    READ strAddr, char                  'read byte from EEPROM\n    strAddr = strAddr + 1               'point to next character\n    IF (char = 0) THEN EXIT             'if 0, exit routine\n    DEBUG char                          'otherwise print char\n  LOOP\n  RETURN",
		"WRITE.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: WRITE\n'This program writes some data to EEPROM and then reads them back out\n'and displays the data in the Debug Terminal.  It also demonstrates\n'writing both bytes and words, and the results of reading values as\n'bytes or words.\n\nidx             VAR     Byte            'loop control\nvalue           VAR     Word(3)         'value(s)\n\nInit:\n  PAUSE 200                             'short startup-pause\n\nMain:\n  WRITE 0, 100                          'single byte\n  WRITE 1, Word 1250                    'single word\n  WRITE 3, 45, 90, Word 725             'multi-value write\n\nRead_EE:\n  'read values as bytes only\n  DEBUG \"Values as bytes:\", CR\n  FOR idx = 0 TO 6                      \n    READ idx, value\n    DEBUG DEC1 idx, \" : \", DEC value, CR\n  NEXT\n  DEBUG CR\n\n  'read values as stored\n  DEBUG \"Values as written:\", CR\n  READ 0, value\n  DEBUG DEC value, CR\n  READ 1, Word value\n  DEBUG DEC value, CR\n  READ 3, value(0), value(1), Word value(2)\n  FOR idx = 0 TO 2\n    DEBUG DEC value(idx), CR\n  NEXT\n  END",
	},
	"bs2": {
		"DEBUG_DEBUGIN.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: DEBUG_DEBUGIN\n'This program demonstrates the ability to accept user input from the\n'Debug Terminal, and to accept numeric entry in any valid format.\n\nmyNum           VAR     Word\n\nInit:\n  PAUSE 200                             'short startup-pause\n\nMain:\n  DO\n    DEBUG CLS, \"Enter a any number: \"   'prompt user\n    DEBUGIN SNUM myNum                  'retrieve number in any format\n\n    DEBUG CRSRXY, 0, 2,                 'display number in all formats\n          SDEC ? myNum,\n          SHEX ? myNum,\n          SBIN ? myNum\n    PAUSE 3000\n  LOOP                                  'do it again",
		"DTMFOUT.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: DTMFOUT\n'This demo program is a rudimentary memory dialer. Since DTMF digits fit\n'within a nibble (four bits), the program below packs two DTMF digits into\n'each byte of three EEPROM data tables. The end of phone number is marked\n'by the nibble $F, since this is not a valid phone-dialing digit.\n'Conditional compilation sets the timing adjustment factor so that the\n'output will sound the same on any BS2 model.\n\nSpkr            PIN     10              'DTMF output on pin 10\n\n#SELECT $STAMP                          'Set TmAdj according to module type\n  #CASE BS2, BS2E, BS2PE\n    TmAdj       CON     $100            'x 1.0 (time adjust)\n  #CASE BS2SX\n    TmAdj       CON     $280            'x 2.5\n  #CASE BS2P\n    TmAdj       CON     $3C5            'x 3.77\n  #CASE BS2PX\n    TmAdj       CON     $607            'x 6.03\n#ENDSELECT\n\neeLoc           VAR     Byte            'EEPROM address of stored number\neeByte          VAR     Byte            'Byte containing two DTMF digits\ndtDig           VAR     eeByte.NIB1     'Digit to dial\nphone           VAR     Nib             'Pick a phone #\nhiLo            VAR     Bit             'Bit to select upper and lower nib\n\nParallax        DATA    $19,$16,$62,$48,$33,$3F  'Phone: 1-916-624-8333\nParallaxFax     DATA    $19,$16,$62,$48,$00,$3F  'Phone: 1-916-624-8003\nInformation     DATA    $15,$20,$55,$51,$21,$2F  'Phone: 1-520-555-1212\n\nMain:\n  FOR phone = 0 TO 2\n    'retrieve address\n    LOOKUP phone, [Parallax, ParallaxFax, Information], eeLoc\n    GOSUB Dial_Number\n    PAUSE 2000\n  NEXT\n  END\n\nDial_Number:\n  DO\n    READ eeLoc, eeByte                  'Retrieve byte from EEPROM\n    eeLoc = eeLoc + 1                   'point to next pair of digits\n    FOR hiLo = 0 TO 1                   'Dial upper and lower digits\n      IF (dtDig = $F) THEN EXIT         'Hex $F is end-of-number flag\n      DTMFOUT Spkr,                     'dial digit\n              150 */ TmAdj, 25, [dtDig] '150 ms on, 25 ms off\n      eeByte = eeByte << 4              'Shift in next digit\n    NEXT\n  LOOP UNTIL (dtDig = $F)\n  RETURN\n",
		"NAP.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: NAP\n'This program lights an LED setting pin 0 low. This completes the circuit \n'from +5V, through the LED and resistor, to ground. During the NAP interval,\n'the LED stays lit, but blinks off for a fraction of a second.  This blink\n'is caused by the NAP wake-up mechanism.  During wake-up, all pins briefly\n'slip into input mode, effectively disconnecting them from loads.\n\nSetup:\n  LOW 0                                 'turn LED on\n\nSnooze:\n  DO\n    NAP 4                               'nap for fraction of a second\n  LOOP",
		"PULSIN.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: PULSIN\n'This program uses PULSIN to measure a pulse generated by discharging a\n'0.1 uF capacitor through a 1K resistor. Pressing the switch generates\n'the pulse, which should ideally be approximately 120 us (60 PULSIN units\n'of 2 us) long (for BS2 and BS2e). Variations in component values may\n'produce results that are up to 10 units off from this value.  For more\n'information on calculating resistor-capacitor timing, see the RCTIME\n'command.\n\nPulse           PIN     7                     'pulse input pin\n\n#SELECT $STAMP                                'Set Scale according to module type\n  #CASE BS2, BS2E, BS2PE\n    Scale       CON     $200                  '2.0 us per unit\n  #CASE BS2SX\n    Scale       CON     $0CC                  '0.8 us per unit\n  #CASE BS2P\n    Scale       CON     $0C0                  '0.75 us per unit\n  #CASE BS2PX\n    Scale       CON     $0CF                  '0.81 us per unit\n#ENDSELECT\n\ntime            VAR     Word\n\nInit:\n  PAUSE 200                             'short startup-pause\n\nMain:\n  DO\n    PULSIN Pulse, 1, time                     'measure positive pulse\n    IF (time > 0) THEN                        'if not 0\n      DEBUG HOME, DEC time, \" units \", CLREOL 'display raw input\n      time = time */ Scale                    'adjust for Stamp\n      DEBUG CR, DEC time, \" us  \"             'display microseconds\n    ELSE\n      DEBUG CLS, \"Out of Range\"               'else error message\n    ENDIF\n  PAUSE 200\n  LOOP\n",
		"PULSOUT.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: PULSOUT\n'This program blinks an LED on for 25 ms at 1-second intervals. Connect an\n'LED (active-low) to I/O pin 0.\n\n#SELECT $STAMP                          'Set Scale according to module type\n  #CASE BS2, BS2E, BS2PE\n    Scale       CON     500             'to ms for 2 us per unit\n  #CASE BS2SX, BS2P, BS2PX\n    Scale       CON     1250            'to ms for 0.8 us per unit\n#ENDSELECT\n\nFlash           CON     25 * Scale      '25 milliseconds\n\nSetup:\n  PAUSE 200                             'short startup-pause\n  HIGH 0                                'make P0 high (LED off)\n\nMain:\n  DO\n    PULSOUT 0, Flash                    'flash LED\n    PAUSE 1000                          'one second delay\n  LOOP",
		"PWM.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: PWM\n'Connect a voltmeter (such as a digital multimeter set to its voltage\n'range) to the output of the circuit shown in the figure for the PWM\n'command.  Run the program and observe the readings on the meter. They\n'should come very close to 1.96V, then decrease slightly as the capacitor\n'discharges. Try varying the interval between PWM bursts (by changing the\n'PAUSE value) and the number of PWM cycles to see their effect.\n\n#SELECT $stamp                          'Set CycAdj according to module type\n  #CASE BS2, BS2E\n    CycAdj      CON     $100            'x 1.0, cycle adjustment (for ms)\n  #CASE BS2SX\n    CycAdj      CON     $280            'x 2.5\n  #CASE BS2P\n    CycAdj      CON     $187            'x 1.53\n  #CASE BS2PE\n    CycAdj      CON     $09E            'x 0.62\n  #CASE BS2PX\n    CycAdj      CON     $280            'x 2.5\n#ENDSELECT\n\nCycles          CON     50\n\nMain:\n  DO\n    PWM 0, 100, (Cycles */ CycAdj)      'PWM at 100/255 duty (~50 ms)\n    PAUSE 1000                          'wait one second\n  LOOP",
		"REVERSE.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: REVERSE\n'Connect the circuit shown in the REVERSE command description to I/O pin\n'0 and run this program.  The LED will alternate between two states, dim\n'and bright. The BASIC Stamp is using the REVERSE command to toggle I/O\n'pin 0 between input and output states. When pin 0 is an input, current\n'flows through R1, through the LED, through R2 to ground. Pin 0 is\n'effectively disconnected and doesn't play a part in the circuit. The total\n'resistance encountered by current flowing through the LED is R1 + R2 = 1220\n'ohms. When pin 0 is reversed to an output, current flows through R1, through\n'the LED, and into pin 0 to ground (because of the 0 written to OUT0). The\n'total resistance encountered by current flowing through the LED is R1,\n'220 ohms. With only 20% of the resistance, the LED glows brighter.\n\nSetup:\n  OUT0 = 0                              'Put a low in the pin 0\n                                        ' output driver\nMain:\n  DO\n    PAUSE 250                             '1/4th second pause\n    REVERSE 0                             'reverse pin 0 I/O direction\n  LOOP                                    'do forever",
		"SELECT-CASE.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: SELECT-CASE\n'This program generates a series of 16-bit random numbers and tests each\n'to determine odd or even, and where it falls in the possible range:\n'lower third, middle third, or upper third.  The program is useful for\n'testing various seed values for RANDOM.\n\ntest            VAR     Byte            'counter for tests\nsample          VAR     Word            'random number to be tested\nodd             VAR     Byte            'odd throws\neven            VAR     Byte            'even throws\nisLo            VAR     Byte            'sample in lower third\nisMid           VAR     Byte            '       in middle thrid\nisHi            VAR     Byte            '       in upper third\n\nInit:\n  PAUSE 200                             'short startup-pause\n\nMain:\n  sample = 11000                        'initialize seed\n  FOR test = 1 TO 100                   '\"throw\" 100 times\n    RANDOM sample                       'randomize\n\n    IF (sample.BIT0) THEN               'check odd/even bit\n      odd = odd + 1                     'increment odd count\n    ELSE\n      even = even + 1                   'increment even count\n    ENDIF\n\n    SELECT sample\n      CASE <= 21845                     'test lower third\n        isLo = isLo + 1\n\n      CASE 21846 TO 43691               'test middle third\n        isMid = isMid + 1\n\n      CASE ELSE                         'otherwise upper third\n        isHi = isHi + 1\n    ENDSELECT\n  NEXT\n\nShow_Results:\n  DEBUG CLS,\n        \"Odd Throws.... \", DEC odd, \"%\", CR,\n        \"Even Throws... \", DEC even, \"%\", CR,\n        \"Low........... \", DEC isLo, \"%\", CR,\n        \"Mid........... \", DEC isMid, \"%\", CR,\n        \"High.......... \", DEC isHi, \"%\", CR\n  END",
		"SERIN_SEROUT1.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: SERIN_SEROUT1\n'Using two BS2-IC's, connect the circuit shown in the SERIN command\n'description and run this program on the BASIC Stamp designated as the\n'Sender. This program demonstrates the use of Flow Control (FPin).\n'Without flow control, the sender would transmit the whole word \"Hello!\"\n'in about 1.5 ms. The receiver would catch the first byte at most; by the\n'time it got back from the first 1-second PAUSE, the rest of the data\n'would be long gone. With flow control, communication is flawless since\n'the sender waits for the receiver to catch up.\n\nSO              PIN     1               'serial output\nFC              PIN     0               'flow control pin\n\n#SELECT $STAMP                          'Set values according to module type\n  #CASE BS2, BS2E, BS2PE\n    T1200       CON     813\n    T2400       CON     396\n    T9600       CON     84\n    T19K2       CON     32\n    T38K4       CON     6\n  #CASE BS2SX, BS2P\n    T1200       CON     2063\n    T2400       CON     1021\n    T9600       CON     240\n    T19K2       CON     110\n    T38K4       CON     45\n  #CASE BS2PX\n    T1200       CON     3313\n    T2400       CON     1646\n    T9600       CON     396\n    T19K2       CON     188\n    T38K4       CON     84\n#ENDSELECT\n\nInverted        CON     $4000\nOpen            CON     $8000\nBaud            CON     T9600 + Inverted\n\nInit:\n  PAUSE 200                             'short startup-pause\n\nMain:\n  DO\n    SEROUT SO\\FC, Baud, [\"Hello!\", CR]  'send the greeting\n    PAUSE 2500                          'wait 2.5 seconds\n  LOOP                                  'repeat forever",
		"SERIN_SEROUT2.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: SERIN_SEROUT2\n'Using two BS2-IC's, connect the circuit shown in the SERIN command\n'description and run this program on the BASIC Stamp designated as the\n'Receiver.  This program demonstrates the use of Flow Control (FPin).\n'Without flow control, the sender would transmit the whole word \"Hello!\"\n'in about 1.5 ms. The receiver would catch the first byte at most; by the\n'time it got back from the first 1-second PAUSE, the rest of the data\n'would be long gone. With flow control, communication is flawless since\n'the sender waits for the receiver to catch up.\n\nSI              PIN     1               'serial input\nFC              PIN     0               'flow control pin\n\n#SELECT $STAMP                          'Set values according to module type\n  #CASE BS2, BS2E, BS2PE\n    T1200       CON     813\n    T2400       CON     396\n    T9600       CON     84\n    T19K2       CON     32\n    T38K4       CON     6\n  #CASE BS2SX, BS2P\n    T1200       CON     2063\n    T2400       CON     1021\n    T9600       CON     240\n    T19K2       CON     110\n    T38K4       CON     45\n  #CASE BS2PX\n    T1200       CON     3313\n    T2400       CON     1646\n    T9600       CON     396\n    T19K2       CON     188\n    T38K4       CON     84\n#ENDSELECT\n\nInverted        CON     $4000\nOpen            CON     $8000\nBaud            CON     T9600 + Inverted\n\nletter          VAR     Byte\n\nInit:\n  PAUSE 200                             'short startup-pause\n\nMain:\n  DO\n    SERIN SI\\FC, Baud, [letter]         'receive one byte\n    DEBUG letter                        'display on screen\n    PAUSE 1000                          'wait one second\n  LOOP                                  'repeat forever",
		"SHIFTIN.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: SHIFTIN\n'This program uses the SHIFTIN instruction to interface with the ADC0831\n'8-bit analog-to-digital converter from National Semiconductor.\n\nCS              PIN     0                       'chip select\nAData           PIN     1                       'data pin\nClk             PIN     2                       'clock pin\n\nadcRes          VAR     Byte                    'ADC result\n\nSetup:\n  PAUSE 200                                     'short startup-pause\n  HIGH CS                                       'deselect ADC\n\n'In the loop below, just three lines of code are required to read the\n'ADC0831. The SHIFTIN command does most of the work.  The mode argument in\n'the SHIFTIN command specifies MSB or LSB-first and whether to sample data\n'before or after the clock. In this case, we chose MSB-first, post-clock.\n'The ADC0831 precedes its data output with a dummy bit, which we take care\n'of by specifying 9 bits of data instead of 8.\n\nMain:\n  DO\n    LOW CS                                      'activate the ADC0831\n    SHIFTIN AData, Clk, MSBPOST, [adcRes\\9]     'shift in the data\n    HIGH CS                                     'deactivate ADC0831\n    DEBUG ? adcRes                              'show conversion result\n    PAUSE 1000                                  'wait one second\n  LOOP                                          'repeat",
		"SHIFTOUT.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: SHIFTOUT\n'This program uses the SHIFTOUT command to interface to the 74HC595 shift\n'register as an 8-bit output port.  The 74HC595 requires a minimum of three\n'inputs: data, clock, and latch.  See the figure in the SHIFTOUT command\n'description for wiring information. SHIFTOUT automatically handles the data\n'and clock, pulsing the clock to shift data bits into the 74HC595. An extra\n'step (pulsing the latch input) is required to move the shifted bits in\n'parallel onto the 74HC595's output pins.  Note: this code does not control\n'the output-enable or reset lines of the 74HC595.  This means that before the\n'BASIC Stamp first sends, the 74HC595's output latches are turned on and may\n'contain random data.  In critical applications, you should hold output-enable\n'high (disabled) until the BASIC Stamp can take control.\n\nDpin            PIN     0                       'data pin to 74HC595\nClk             PIN     1                       'shift clock to 74HC595\nLatch           PIN     2                       'latch 74HC595 outputs\n\ncounter         VAR     Byte\n\nSetup:\n  LOW Latch                                     'initialize latch output\n\n'This loop moves the 8-bit value 'counter' onto the output lines of the\n'74HC595, pauses, then increments counter and repeats.  The data is shifted\n'msb first so that the msb appears on pin QH and the lsb on QA. Changing\n'MSBFIRST to LSBFIRST causes the data to appear backwards on the outputs.\n\nMain:\n  DO\n    SHIFTOUT Dpin, Clk, MSBFIRST, [counter]     'send the bits\n    PULSOUT Latch, 1                            'transfer to outputs\n    PAUSE 100                                   'Wait 0.1 seconds\n    counter = counter + 1                       'increment counter\n  LOOP",
		"TOGGLE.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: TOGGLE\n'Connect LEDs to pins 0 through 3 as shown in the TOGGLE command description\n'and run this program. The TOGGLE command will treat you to a light show.\n'You may also run the demo without LEDs; the Debug Terminal will show you the\n'states of pins 0 through 3.\n\nthePin          VAR     Nib             'pin 0 - 3\n\nSetup:\n  PAUSE 200                             'short startup-pause\n  DIRA = %1111                          'make LEDs output, low\n\nMain:\n  DEBUG \"LED States: \"\n  DO\n    FOR thePin = 0 TO 3                 'loop through pins\n      TOGGLE thePin                     'toggle current pin\n      DEBUG CRSRXY, 12, 0, BIN4 OUTA    'show on Debug Terminal\n      PAUSE 250                         'short delay\n    NEXT\n  LOOP                                  'repeat forever",
		"XOUT.bs2": "'{$STAMP BS2}\n'{$PBASIC 2.5}\n\n'SOURCE: XOUT\n'This program--really two program fragments--demonstrates the syntax and\n'use of the XOUT command. XOUT works like pressing the buttons on an X-10\n'control box; first you press one of 16 keys to identify the unit you want\n'to control, then you press the key for the action you want that unit to\n'take (turn ON, OFF, Bright, or Dim). There are also two group-action keys,\n'Lights ON and All OFF. Lights ON turns all lamp modules on without\n'affecting appliance modules. All OFF turns off all modules, both lamp and\n'appliance types.  Connect the BASIC Stamp to a power-line interface as\n'shown in the XOUT command description in the manual.\n\nMpin            PIN     1               'modulation pin\nZpin            PIN     0               'zero-cross input\n\nHouseA          CON     0               'House code A = 0\nUnit1           CON     0               'Unit code 1 = 0\nUnit2           CON     1               'Unit code 2 = 1\n\n'This first example turns a standard (appliance or non-dimmer lamp) module\n'ON, then OFF. Note that once the Unit code is sent, it need not be repeated\n'--subsequent instructions are understood to be addressed to that unit.\n\nMain:\n  XOUT Mpin, Zpin, [HouseA\\Unit1\\2]     'select Unit1 (appliance module)\n  XOUT Mpin, Zpin, [HouseA\\UNITON]      'turn it on\n\n  PAUSE 1000                            'wait one second\n\n  XOUT Mpin, Zpin, [HouseA\\UNITOFF]     'then turn it off\n\n'The next example talks to a lamp module using the dimmer feature. Dimmers\n'go from full ON to dimmed OFF in 19 steps. Because dimming is relative to\n'the current state of the lamp, the only guaranteed way to set a predefined\n'brightness level is to turn the dimmer fully OFF, then ON, then dim to the\n'desired level.\n\n  XOUT Mpin, Zpin, [HouseA\\Unit2\\2]     'select Unit2 (lamp module)\n\n'This example shows the use of the optional Cycles argument.  Here we DIM\n'for 10 cycles.\n\n  XOUT Mpin, Zpin, [HouseA\\UNITOFF\\2, HouseA\\DIM\\10]\n  STOP"
	},
	"other": {
		"AUX_TERM.bs2": "'{$STAMP BS2p}\n'{$PBASIC 2.5}\n\n'SOURCE: AUX_MAIN_TERM\n'This program demonstrates the use of the AUXIO, MAINIO and IOTERM\n'commands to affect I/O pins in the auxiliary and main I/O groups.\n\nInit:\n  PAUSE 200                             'short startup-pause\n\n#SELECT $STAMP                          'Notify of module requirements\n  #CASE BS2, BS2E, BS2SX\n    #ERROR \"Program requires BS2p40\"\n  #CASE BS2P, BS2PE, BS2PX\n    DEBUG \"Note: This program is designed for the BS2p40.\", CR\n#ENDSELECT\n\nport            VAR     Bit\n\nMain:\n  DO\n    MAINIO                              'Switch to main I/O pins\n    TOGGLE 0                            'Toggle state of I/O pin P0\n    PWM 1, 100, 40                      'Generate PWM on I/O pin P1\n\n    AUXIO                               'Switch to auxiliary I/O pins\n    TOGGLE 0                            'Toggle state of I/O pin X0\n    PULSOUT 1, 1000                     'Generate a pulse on I/O pin X1\n    PWM 2, 100, 40                      'Generate PWM on I/O pin X2\n\n    IOTERM port                         'Switch to main or aux I/Os\n                                        '-- depending on port\n    TOGGLE 3                            'Toggle state of I/O pin 3\n                                        '-- on main and aux, alternately\n    port = ~port                        'Invert port\n    PAUSE 1000                          '1 second delay\n  LOOP\n",
		"I2C.bs2": "'{$STAMP BS2p}\n'{$PBASIC 2.5}\n\n'SOURCE: I2C\n'This program demonstrates writing and reading every location in a 24LC16B\n'EEPROM using the BS2p/BS2pe's I2C commands.  Connect the BS2p, BS2pe,  or\n'BS2px to the 24LC16B DIP EEPROM as shown in the diagram in the I2CIN OR\n'I2COUT command description.\n\n#IF ($STAMP < BS2P) #THEN               'Notify of module requirements\n  #ERROR \"Program requires BS2p, BS2pe, or BS2px.\"\n#ENDIF\n\nSDA             PIN     0               'I2C SDA pin\nSCL             PIN     SDA + 1\n\naddr            VAR     Word            'internal address\nblock           VAR     Nib             'block address in 24LC16\nvalue           VAR     Byte            'value to write\ncheck           VAR     Nib             'for checking retuned values\nresult          VAR     Byte(16)        'array for returned value\n\nInit:\n  PAUSE 200                             'short startup-pause\n\nWrite_To_EEPROM:\n  DEBUG \"Writing...\", CR\n  PAUSE 2000\n  FOR addr = 0 TO 2047 STEP 16          'loop through all addresses\n    block = addr.NIB2 << 1              'calculate block address\n    value = addr >> 4                   'create value from upper 8 bits\n    'write 16 bytes\n    I2COUT SDA, $A0 | block, addr, [REP value\\16]\n    PAUSE 5\n    DEBUG \"Addr: \", DEC4 addr, \"-\", DEC4 addr + 15, \"  \",\n          \"Value: \", DEC3 value, CR\n  NEXT\n  PAUSE 2000\n\nRead_From_EEPROM:\n  DEBUG CR, \"Reading...\", CR\n  PAUSE  2000\n  FOR addr = 0 TO 2047 STEP 16\n    block = addr.NIB2 << 1\n    value = addr >> 4\n    I2CIN SDA, $A1 | block, addr, [STR result\\16]\n    FOR check = 0 TO 15\n      IF (result(check) <> value) THEN Error\n    NEXT\n    DEBUG \"Addr: \", DEC4 addr, \"-\", DEC4 addr + 15, \"  \",\n          \"Value: \", DEC3 result, CR\n  NEXT\n  PAUSE 100\n  DEBUG CR, \"All locations passed\"\n  END\n\nError:\n  DEBUG \"Error at location: \", DEC4 addr + check, CR,\n        \"Found: \", DEC3 result(check), \", Expected: \", DEC3 value",
		"OWIN_OWOUT.bs2": "'{$STAMP BS2p}\n'{$PBASIC 2.5}\n\n'SOURCE: OWIN_OWOUT\n'This program demonstrates interfacing to a Dallas Semiconductor DS1822\n'1-Wire Digital Thermometer chip using the BS2p's 1-Wire commands. Connect\n'the BS2p, BS2pe, or BS2px to the DS1822 as shown in the diagram in the\n'OWIN or OWOUT command description. This program uses a simplified\n'approach that ignores the fractional portion of the temperature.\n\n#IF ($STAMP < BS2P) #THEN               'Notify of module requirements\n  #ERROR \"Program requires BS2p, BS2pe or BS2px.\"\n#ENDIF\n\nDQ              PIN     0               '1-Wire buss pin\n\nRdROM           CON     $33             'read serial number\nMatchROM        CON     $55             'match SN -- for multiple devices\nSkipROM         CON     $CC             'ignore SN -- use for one device\nCvrtTmp         CON     $44             'start temperature conversion\nRdSP            CON     $BE             'read DS1822 scratch pad\n\ntempIn          VAR     Word            'raw temperature\nsign            VAR     tempIn.BIT11    '1 = negative temperature\ntLo             VAR     tempIn.BYTE0\ntHi             VAR     tempIn.BYTE1\ntSign           VAR     Bit             'saved sign bit\ntempC           VAR     Word            'final Celsius temp\ntempF           VAR     Word            'final Fahrenheit temp\n\nInit:\n  PAUSE 200                             'short startup-pause\n\nMain:\n  DO\n    GOSUB Get_Temperature               'read temperature from DS1822\n    DEBUG HOME,                         'display\n          \"DS1822\", CR,\n          \"------\", CR,\n          SDEC tempC, \" C \", CR,\n          SDEC tempF, \" F \"\n     PAUSE 1000\n  LOOP\n  END\n\nGet_Temperature:\n  OWOUT DQ, 1, [SkipROM, CvrtTmp]       'send convert temperature command\n  DO                                    'wait on conversion\n    PAUSE 25                            'small loop pad\n    OWIN DQ, 4, [tempIn]                'check status (bit transfer)\n  LOOP UNTIL (tempIn)                   '1 when complete\n  OWOUT DQ, 1, [SkipROM, RdSP]          'read DS1822 scratch pad\n  OWIN  DQ, 2, [tLo, tHi]               'get raw temp data\n  tSign = sign                          'save sign bit\n  tempC = tempIn >> 4                   'round to whole degrees\n  tempC.BYTE1 = $FF * tSign             'correct twos complement bits\n  tempF = (ABS tempC) * 9 / 5           'start F conversion\n  IF (tSign) THEN                       'finish F conversion\n    tempF = 32 - tempF                  'C was negative\n  ELSE\n    tempF = tempF + 32                  'C was positive\n  ENDIF\n  RETURN",
		"STOREALL.bs2": "'{$STAMP BS2p}\n'{$PBASIC 2.5}\n\n'SOURCE: STOREALL\n'This program demonstrates the STORE command and how it can be used to\n'\"flatten\" the EEPROM space for applications requiring a lot of storage.\n'This program writes to EEPROM locations within program slots 1 though 7\n'on the BS2p and BS2px, and 1 through 15 on the BS2pe, thus, has access to\n'14 or 30 kBytes of space.\n\n#SELECT $STAMP                                  'Notify of module requirements\n  #CASE BS2, BS2E, BS2SX\n    #ERROR \"Program requires BS2p, BS2pe or BS2px.\"\n  #CASE BS2P, BS2PX\n    HiSlot      CON     7\n  #CASE BS2PE\n    HiSlot      CON     15\n#ENDSELECT\n\nLoSlot          CON     1                       'first slot for \"flat\" EE\nMemSize         CON     HiSlot - LoSlot + 1 * 2048\n\neeAddr          VAR     Word                    'address pointer\nvalue           VAR     Word                    'cell value\nslot            VAR     Byte                    'current R/W slot\n\nInit:\n  PAUSE 200                             'short startup-pause\n\nMain:\n  DEBUG \"Flat Memory\", CR,\n        \"---------------------\", CR,\n        \"First Slot..... \", DEC LoSlot, CR,\n        \"Last Slot...... \", DEC HiSlot, CR,\n        \"Flat EE Size... \", DEC MemSize, CR, CR\n\n  PAUSE 2000\n  DEBUG \"Writing to flat Memory...\", CR\n  PAUSE 1000\n  FOR eeAddr = 0 TO (MemSize - 1) STEP 128      'step through \"flat\" EE\n    value = eeAddr * 2                          'generate value\n    GOSUB Write_Word                            'write it\n    GET 127, slot                               'get R/W slot\n    DEBUG \"--> Location: \", DEC5 eeAddr, \"   \", 'show \"flat\" address\n          \"Value: \", DEC5 value, \"   \",         'show value\n          \"(\", DEC slot.NIB1, \")\", CR           'show slot\n  NEXT\n  DEBUG CR\n\n  DEBUG \"Reading from flat Memory...\", CR\n  PAUSE 1000\n  FOR eeAddr = 0 TO (MemSize - 1) STEP 128\n    GOSUB Read_Word                             'read value from EE\n    GET 127, slot                               'get W/R slot\n    DEBUG \"<-- Location: \", DEC5 eeAddr, \"   \",\n          \"Value: \", DEC5 value, \"   \",\n          \"(\", DEC slot.NIB1, \")  \"\n     IF (value <> (2 * eeAddr)) THEN            'verify location\n      DEBUG \"- Error\"\n    ENDIF\n    DEBUG CR\n  NEXT\n  END\n\nWrite_Word:\n'NOTE: only use even-byte eeAddr with this routine\n  STORE (eeAddr >> 11) + LoSlot                 'set slot\n  WRITE eeAddr, Word value                      'write value\n  RETURN\n\nRead_Word:\n'NOTE: only use even-byte eeAddr with this routine\n  STORE (eeAddr >> 11) + LoSlot                 'set slot\n  READ eeAddr, Word value                       'read value\n  RETURN"
	},
	"lcd": {
		"LCDCMD.bs2": "'{$STAMP BS2p}\n'{$PBASIC 2.5}\n\n'SOURCE: LCDCMD\n'This program demonstrates initialization and printing on a 2 x 16\n'character LCD display. The set of \"LCD constants\", below, are provided\n'as pre-defined and useful LCD commands, though not all are actually\n'used in this program.\n\n#IF ($stamp < BS2P) #THEN       'Notify of module requirements\n  #ERROR \"Program requires BS2p, BS2pe, or BS2px.\"\n#ENDIF\n\nLcd             PIN     0\n\nLcdCls          CON     $01     'clear the LCD\nLcdHome         CON     $02     'move cursor home\nLcdCrsrL        CON     $10     'move cursor left\nLcdCrsrR        CON     $14     'move cursor right\nLcdDispL        CON     $18     'shift chars left\nLcdDispR        CON     $1C     'shift chars right\nLcdDDRam        CON     $80     'Display Data RAM\nLcdCGRam        CON     $40     'Character Generator RAM\nLcdLine1        CON     $80     'DDRAM address of line 1\nLcdLine2        CON     $C0     'DDRAM address of line 2\n\n\nInit_LCD:\n  PAUSE 1000                    'allow LCD to self-initialize first\n  LCDCMD Lcd, %00110000         'send wakeup sequence to LCD\n  PAUSE 5                       'pause required by LCD specs\n  LCDCMD Lcd, %00110000\n  PAUSE 0                       'pause required by LCD specs\n  LCDCMD Lcd, %00110000\n  PAUSE 0                       'pause required by LCD specs\n  LCDCMD Lcd, %00100000         'set data bus to 4-bit mode\n  LCDCMD Lcd, %00101000         'set to 2-line mode with 5x8 font\n  LCDCMD Lcd, %00001100         'display on without cursor\n  LCDCMD Lcd, %00000110         'auto-increment cursor\n\nMain:\n  DO\n    LCDOUT Lcd, LcdCls, [\"Hello, World!\"]\n    LCDOUT Lcd, LcdLine2, [\"How are you?\"]\n    PAUSE 3000\n    LCDCMD Lcd, LcdCls\n    PAUSE 500\n  LOOP",
		"LCDIN.bs2": "'{$STAMP BS2p}\n'{$PBASIC 2.5}\n\n'SOURCE: LCDIN\n'This program demonstrates initialization, printing and reading\n'from a 2 x 16 character LCD display.\n\n#IF ($STAMP < BS2P) #THEN       'Notify of module requirements\n  #ERROR \"Program requires BS2p, BS2pe or BS2px.\"\n#ENDIF\n\nLcd             PIN     0\n\nLcdCls          CON     $01     'clear the LCD\nLcdHome         CON     $02     'move cursor home\nLcdCrsrL        CON     $10     'move cursor left\nLcdCrsrR        CON     $14     'move cursor right\nLcdDispL        CON     $18     'shift chars left\nLcdDispR        CON     $1C     'shift chars right\nLcdDDRam        CON     $80     'Display Data RAM\nLcdCGRam        CON     $40     'Character Generator RAM\nLcdLine1        CON     $80     'DDRAM address of line 1\nLcdLine2        CON     $C0     'DDRAM address of line 2\n\nchar            VAR     Byte(16)\n\nInit_LCD:\n  PAUSE 1000                    'allow LCD to self-initialize first\n  LCDCMD Lcd, %00110000         'send wakeup sequence to LCD\n  PAUSE 5                       'pause required by LCD specs\n  LCDCMD Lcd, %00110000\n  PAUSE 0                       'pause required by LCD specs\n  LCDCMD Lcd, %00110000\n  PAUSE 0                       'pause required by LCD specs\n  LCDCMD Lcd, %00100000         'set data bus to 4-bit mode\n  LCDCMD Lcd, %00101000         'set to 2-line mode with 5x8 font\n  LCDCMD Lcd, %00001100         'display on without cursor\n  LCDCMD Lcd, %00000110         'auto-increment cursor\n\nMain:\n  DO\n    LCDOUT Lcd, LcdCls, [\"Hello!\"]\n    GOSUB Read_LCD_Screen\n    PAUSE 3000\n    LCDOUT Lcd, LcdCls, [\"I'm a 2x16 LCD!\"]\n    GOSUB Read_LCD_Screen\n    PAUSE 3000\n  LOOP\n\nRead_LCD_Screen:\n  DEBUG \"LCD now says: \"\n  LCDIN Lcd, LcdLine1, [STR char\\16]\n  DEBUG STR char\\16, CR\n  RETURN",
		"LCDINIT.bs2": "'{$STAMP BS2p}\n'{$PBASIC 2.5}\n\n'SOURCE: LCDINIT\n'This program demonstrates initialization and printing on a 2 x 16\n'character LCD display. The set of \"LCD constants\", below, are provided\n'as pre-defined and useful LCD commands, though not all are actually\n'used in this program.\n\n#IF ($STAMP < BS2P) #THEN       'Notify of module requirements\n  #ERROR \"Program requires BS2p, BS2pe or BS2px.\"\n#ENDIF\n\nLcd             PIN     0\n\nLcdCls          CON     $01     'clear the LCD\nLcdHome         CON     $02     'move cursor home\nLcdCrsrL        CON     $10     'move cursor left\nLcdCrsrR        CON     $14     'move cursor right\nLcdDispL        CON     $18     'shift chars left\nLcdDispR        CON     $1C     'shift chars right\nLcdDDRam        CON     $80     'Display Data RAM\nLcdCGRam        CON     $40     'Character Generator RAM\nLcdLine1        CON     $80     'DDRAM address of line 1\nLcdLine2        CON     $C0     'DDRAM address of line 2\n\n\nInit_LCD:\n  PAUSE 1000                    'allow LCD to self-initialize first\n  LCDCMD Lcd, %00110000         'send wakeup sequence to LCD\n  PAUSE 5                       'pause required by LCD specs\n  LCDCMD Lcd, %00110000\n  PAUSE 0                       'pause required by LCD specs\n  LCDCMD Lcd, %00110000\n  PAUSE 0                       'pause required by LCD specs\n  LCDCMD Lcd, %00100000         'set data bus to 4-bit mode\n  LCDCMD Lcd, %00101000         'set to 2-line mode with 5x8 font\n  LCDCMD Lcd, %00001100         'display on without cursor\n  LCDCMD Lcd, %00000110         'auto-increment cursor\n\nMain:\n  DO\n    LCDOUT Lcd, LcdCls, [\"Hello, World!\"]\n    LCDOUT Lcd, LcdLine2, [\"How are you?\"]\n    PAUSE 3000\n    LCDCMD Lcd, LcdCls\n    PAUSE 500\n  LOOP",
		"LCDOUT.bs2": "'{$STAMP BS2p}\n'{$PBASIC 2.5}\n\n'SOURCE: LCDOUT\n'This program demonstrates initialization and printing on a 2x16\n'character LCD display.\n\n#IF ($STAMP < BS2P) #THEN       'Notify of module requirements\n  #ERROR \"Program requires BS2p, BS2pe or BS2px.\"\n#ENDIF\n\nLcd             PIN     0\n\nLcdCls          CON     $01     'clear the LCD\nLcdHome         CON     $02     'move cursor home\nLcdCrsrL        CON     $10     'move cursor left\nLcdCrsrR        CON     $14     'move cursor right\nLcdDispL        CON     $18     'shift chars left\nLcdDispR        CON     $1C     'shift chars right\nLcdDDRam        CON     $80     'Display Data RAM\nLcdCGRam        CON     $40     'Character Generator RAM\nLcdLine1        CON     $80     'DDRAM address of line 1\nLcdLine2        CON     $C0     'DDRAM address of line 2\n\n\nInit_LCD:\n  PAUSE 1000                    'allow LCD to self-initialize first\n  LCDCMD Lcd, %00110000         'send wakeup sequence to LCD\n  PAUSE 5                       'pause required by LCD specs\n  LCDCMD Lcd, %00110000\n  PAUSE 0                       'pause required by LCD specs\n  LCDCMD Lcd, %00110000\n  PAUSE 0                       'pause required by LCD specs\n  LCDCMD Lcd, %00100000         'set data bus to 4-bit mode\n  LCDCMD Lcd, %00101000         'set to 2-line mode with 5x8 font\n  LCDCMD Lcd, %00001100         'display on without cursor\n  LCDCMD Lcd, %00000110         'auto-increment cursor\n\n  LCDOUT Lcd, LcdCGRam,         'load custom character map\n         [$00, $0A, $0A, $00, $11, $0E, $06, $00]\n\nMain:\n  DO\n    LCDOUT Lcd, LcdCls, [\"Hello my friend.\"]\n    PAUSE 750\n    LCDOUT Lcd, LcdLine2, [\"How are you?\"]\n    PAUSE 1500\n    LCDCMD Lcd, LcdCls\n    LCDOUT Lcd, LcdLine1 + 1, [\"I'm doing just\"]\n    LCDOUT Lcd, LcdLine2 + 4, [\"fine!  \", 0]\n    PAUSE 2000\n  LOOP"
	}
}
